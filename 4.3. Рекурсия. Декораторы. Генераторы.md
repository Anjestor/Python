# [4.3. Рекурсия. Декораторы. Генераторы](https://education.yandex.ru/handbook/python/article/rekursiya-dekoratory-generatory)
## A. Рекурсивный сумматор
Большинство задач этой главы ориентировано на отработку навыков по разработке рекурсивных функций.  

Ваше решение будет использоваться как библиотека.  

Напишите функцию recursive_sum, которая находит сумму всех позиционных аргументов.  

**Примечание**  
Ваше решение должно содержать только функции.
В решении не должно быть вызовов требуемых функций, за исключением рекурсивных.  
Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.  

---
```python
def recursive_sum(*args):
    return args[-1] + recursive_sum(*args[:-1]) if args else 0
```

## B. Рекурсивный сумматор
Большинство задач этой главы ориентировано на отработку навыков по разработке рекурсивных функций.  

Ваше решение будет использоваться как библиотека.  

Напишите функцию recursive_sum, которая находит сумму всех позиционных аргументов.  

**Примечание**  
Ваше решение должно содержать только функции.  
В решении не должно быть вызовов требуемых функций, за исключением рекурсивных.  
Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.  

---
```python
def recursive_sum(*args):
    return args[-1] + recursive_sum(*args[:-1]) if args else 0
```

## D. Декор результата
Напишите декоратор answer, который преобразует функцию, принимающую неограниченное число позиционных и именованных параметров и возвращает её результат с припиской "Результат функции: <значение>".  

**Примечание**  
Ваше решение должно содержать только функции.  
В решении не должно быть вызовов требуемых функций.  

---
```python
def answer(f):

    def decorated(*args, **kwargs):
        return f'Результат функции: {f(*args, **kwargs)}'
            
    return decorated
```

## E. Накопление результата
В некоторых случаях полезно накапливать результат, а затем получать его единым списком.  

Реализуйте декоратор result_accumulator, который модернизирует функцию с неопределенным количеством позиционных параметров следующим образом:  

- Добавляет именованный параметр method со значением по умолчанию accumulate;  
- При вызове функции с параметром method равным accumulate, результат сохраняется в очередь (для каждой функции в собственную), а функция ничего не возвращает;  
- При вызове функции с параметром method равным drop, возвращается все накопленные результаты, а очередь сбрасывается.  

**Примечание**  
Ваше решение должно содержать только функции.  
В решении не должно быть вызовов требуемых функций.  

---
```python
def result_accumulator(f):
    results = []

    def decorator(*args, method='accumulate'):
        nonlocal results
        results.append(f(*args))
        if method == 'drop':
            tmp, results = results.copy(), list()
            return tmp
    return decorator
```

## G. Однотипность не порок
Во многих задачах требуется контроль входных данных, в частности, несмотря на динамическую типизацию, их типов.  

Разработайте декоратор same_type, который производит проверку переменного количества позиционных параметров. В случае получения не одинаковых типов выводит сообщение "Обнаружены различные типы данных" и прерывает выполнение функции.  

**Примечание**  
Ваше решение должно содержать только функции.  
В решении не должно быть вызовов требуемых функций.  

---
```python
def same_type(f):
    def dec(*args, **kwargs):
        return f(*args) if all(isinstance(i, type(args[0])) for i in args) else print(
               'Обнаружены различные типы данных')
    return dec
```

## H. Генератор Фибоначчи
Числа Фибоначчи весьма интересная последовательность и используется в различных математических задачах. В ней каждый следующий элемент равен сумме двух предыдущих. Математики начинают эту последовательность с двух единиц, но мы же с вами программисты, поэтому привыкли вести счет с нуля.  

Напишите генератор fibonacci, который последовательно возвращает заданное количество чисел Фибоначчи по "правилам программистов".  

**Примечание**  
Ваше решение должно содержать только функции.  
В решении не должно быть вызовов требуемых функций.  

---
```python
def fibonacci(n):
    n_1, n_2 = 0, 1
    for i in range(n):
        yield n_1
        n_1, n_2 = n_2, n_1 + n_2
```

## J. "Выпрямление" списка
Весьма часто, данные, которые мы получаем из различных источников, не удовлетворяют нашим пожеланиям. Одна из частых проблем – излишняя вложенность списков.  

Напишите функцию make_linear, которая принимает список списков и возвращает его "выпрямленное" представление.  

**Примечание**  
Ваше решение должно содержать только функции.  
В решении не должно быть вызовов требуемых функций, за исключением рекурсивных.  
Трассировка вызова рекурсивной функции в обработке ответа не учитывается и показана для примера.  

---
```python
def make_linear(args):
    tmp = list()
    for i in args:
        tmp.append(i) if not isinstance(i, list) else tmp.extend(make_linear(i))
    return tmp
```
