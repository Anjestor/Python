# [5.1. Объектная модель Python. Классы, поля и методы](https://education.yandex.ru/handbook/python/article/obuektnaya-model-python-klassy-polya-i-metody)
## A. Классная точка
Объектно-ориентированное программирование — популярная парадигма в современном мире. Это вполне очевидно, ведь любой объект реального мира мы теперь можем представить в виде цифрового набора полей и методов. Давайте приступим к проектированию классов.  

Разработайте класс Point, который при инициализации принимает координаты точки на декартовой плоскости и сохраняет их в поля x и y соответственно.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

## B. Классная точка 2.0
Давайте расширим функционал класса, написанного в прошлой задаче.  

Реализуйте методы:  

- move, который перемещает точку на заданное расстояние по осям x и y;  
- length, который определяет до переданной точки расстояние, округлённое до сотых.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def move(self, x, y):
        self.x, self.y = self.x + x, self.y + y
    
    def length(self, point):
        return round(((point.x - self.x) ** 2 + (point.y - self.y) ** 2) ** 0.5, 2)
```

## C. Не нажимай красную кнопку!
Если написать предупреждение «Не нажимай красную кнопку!», то её сразу безумно хочется нажать.  

Напишите класс RedButton, который описывает красную кнопку.  

Класс должен реализовывать методы:  

- click() — эмулирует нажатие кнопки, выводит сообщение "Тревога!";  
- count() — возвращает количество раз, которое была нажата кнопка.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class RedButton:
    def __init__(self):
        self.counter = 0

    def click(self):
        self.counter += 1
        print('Тревога!')

    def count(self):
        return self.counter
```

## D. Работа не волк
Рассмотрим объект «Программист», который задаётся именем, должностью и количеством отработанных часов. Каждая должность имеет собственный оклад (заработную плату за час работы). В нашей импровизированной компании существуют 3 должности:  

- Junior — с окладом 10 тугриков в час;  
- Middle — с окладом 15 тугриков в час;  
- Senior — с окладом 20 тугриков в час по умолчанию и +1 тугрик за каждое новое повышение.  

Напишите класс Programmer, который инициализируется именем и должностью (отработка у нового работника равна нулю). Класс реализует следующие методы:  

- work(time) — отмечает новую отработку в количестве часов time;  
- rise() — повышает программиста;  
- info() — возвращает строку для бухгалтерии в формате: <имя> <количество отработанных часов>ч. <накопленная зарплата>тгр.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class Programmer:
    jg = {'Junior': 10, 'Middle': 15, 'Senior': 20}

    def __init__(self, name, qlfctn='Junior'):
        self.name = name
        self.qlfctn = qlfctn
        self.wh = 0
        self.money = 0
        self.salary = self.jg[qlfctn]

    def work(self, time):
        self.wh += time
        self.money += time * self.salary

    def rise(self):
        self.salary = self.jg[list(self.jg)[
                      list(self.jg).index(self.qlfctn) + 1]] if self.qlfctn != 'Senior' else self.salary + 1
        self.qlfctn = list(self.jg)[list(self.jg).index(self.qlfctn) + 1] if self.qlfctn != 'Senior' else 'Senior'

    def info(self):
        return f'{self.name} {self.wh}ч. {self.money}тгр.'
```
## I. Очередь
В программировании существует потребность не только в изученных нами коллекциях. Одна из таких очередь. Она реализует подход к хранению данных по принципу «Первый вошёл – первый ушел».  

Реализуйте класс Queue, который не имеет параметров инициализации, но поддерживает методы:  

- push(item) — добавить элемент в конец очереди;  
- pop() — «вытащить» первый элемент из очереди;  
- is_empty() — проверят очередь на пустоту.  

**Примечание**
Ваше решение должно содержать только классы и функции.
В решении не должно быть вызовов инициализации требуемых классов.

---
```python
class Queue:
    def __init__(self):
        self.ls = []
    
    def push(self, item):
        self.ls.append(item)

    def pop(self):
        return self.ls.pop(0)

    def is_empty(self):
        return True if not self.ls else False
```

## J. Стек
Ещё одной полезной коллекцией является стек реализующий принцип «Последний пришёл – первый ушёл». Его часто представляют как стопку карт или магазин пистолета, где приходящие элементы закрывают выход уже находящимся в коллекции.  

Реализуйте класс Stack, который не имеет параметров инициализации, но поддерживает методы:  

- push(item) — добавить элемент в конец стека;  
- pop() — «вытащить» первый элемент из стека;  
- is_empty() — проверяет стек на пустоту.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class Stack:
    def __init__(self):
        self.ls = []
    
    def push(self, item):
        self.ls.append(item)

    def pop(self):
        return self.ls.pop(-1)

    def is_empty(self):
        return True if not self.ls else False
```
