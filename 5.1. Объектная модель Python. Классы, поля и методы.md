# [5.1. Объектная модель Python. Классы, поля и методы](https://education.yandex.ru/handbook/python/article/obuektnaya-model-python-klassy-polya-i-metody)
## A. Классная точка
Объектно-ориентированное программирование — популярная парадигма в современном мире. Это вполне очевидно, ведь любой объект реального мира мы теперь можем представить в виде цифрового набора полей и методов. Давайте приступим к проектированию классов.  

Разработайте класс Point, который при инициализации принимает координаты точки на декартовой плоскости и сохраняет их в поля x и y соответственно.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
```

## B. Классная точка 2.0
Давайте расширим функционал класса, написанного в прошлой задаче.  

Реализуйте методы:  

- move, который перемещает точку на заданное расстояние по осям x и y;  
- length, который определяет до переданной точки расстояние, округлённое до сотых.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def move(self, x, y):
        self.x, self.y = self.x + x, self.y + y
    
    def length(self, point):
        return round(((point.x - self.x) ** 2 + (point.y - self.y) ** 2) ** 0.5, 2)
```

## C. Не нажимай красную кнопку!
Если написать предупреждение «Не нажимай красную кнопку!», то её сразу безумно хочется нажать.  

Напишите класс RedButton, который описывает красную кнопку.  

Класс должен реализовывать методы:  

- click() — эмулирует нажатие кнопки, выводит сообщение "Тревога!";  
- count() — возвращает количество раз, которое была нажата кнопка.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class RedButton:
    def __init__(self):
        self.counter = 0

    def click(self):
        self.counter += 1
        print('Тревога!')

    def count(self):
        return self.counter
```

## D. Работа не волк
Рассмотрим объект «Программист», который задаётся именем, должностью и количеством отработанных часов. Каждая должность имеет собственный оклад (заработную плату за час работы). В нашей импровизированной компании существуют 3 должности:  

- Junior — с окладом 10 тугриков в час;  
- Middle — с окладом 15 тугриков в час;  
- Senior — с окладом 20 тугриков в час по умолчанию и +1 тугрик за каждое новое повышение.  

Напишите класс Programmer, который инициализируется именем и должностью (отработка у нового работника равна нулю). Класс реализует следующие методы:  

- work(time) — отмечает новую отработку в количестве часов time;  
- rise() — повышает программиста;  
- info() — возвращает строку для бухгалтерии в формате: <имя> <количество отработанных часов>ч. <накопленная зарплата>тгр.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class Programmer:
    jg = {'Junior': 10, 'Middle': 15, 'Senior': 20}

    def __init__(self, name, qlfctn='Junior'):
        self.name = name
        self.qlfctn = qlfctn
        self.wh = 0
        self.money = 0
        self.salary = self.jg[qlfctn]

    def work(self, time):
        self.wh += time
        self.money += time * self.salary

    def rise(self):
        self.salary = self.jg[list(self.jg)[
                      list(self.jg).index(self.qlfctn) + 1]] if self.qlfctn != 'Senior' else self.salary + 1
        self.qlfctn = list(self.jg)[list(self.jg).index(self.qlfctn) + 1] if self.qlfctn != 'Senior' else 'Senior'

    def info(self):
        return f'{self.name} {self.wh}ч. {self.money}тгр.'
```

# E. Классный прямоугольник
Давайте перейдём к более сложным геометрическим фигурам.  

Разработайте класс Rectangle.  

При инициализации класс принимает два кортежа рациональных координат противоположных углов прямоугольника (со сторонами параллельными осям координат).  

Класс должен реализовывать методы:  

- perimeter — возвращает периметр прямоугольника;  
- area — возвращает площадь прямоугольника.  

Все результаты вычислений нужно округлить до сотых.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class Rectangle:
    def __init__(self, *coordinates):
        self.length = abs(coordinates[0][0] - coordinates[1][0])
        self.width = abs(coordinates[0][1] - coordinates[1][1])

    def perimeter(self):
        return round(2 * (self.length + self.width), 2)

    def area(self):
        return round(self.length * self.width, 2)
```

## H. Шашки
Шашки очень занимательная игра, которую достаточно легко моделировать.  

Правила подразумевают наличие двух классов: игральная доска и шашка. Однако мы немного упростим себе задачу и вместо шашки будем манипулировать клетками, которые могут находиться в трех состояниях: пустая, белая шашка и чёрная шашка.  

Разработайте два класса: Checkers и Cell.  

Объекты класса Checkers при инициализации строят игральную доску со стандартным распределением клеток и должны обладать методами:  

- move(f, t) — перемещает шашку из позиции f в позицию t;  
- get_cell(p) — возвращает объект «клетка» в позиции p.

Объекты класса Cell при инициализации принимают одно из трех состояний: W — белая шашка, B — чёрная шашка, X — пустая клетка, а также обладают методом status() возвращающим заложенное в ней состояние.  

Координаты клеток описываются строками вида PQ, где:  

- P — столбец игральной доски, одна из заглавных латинских букв: ABCDEFGH;  
- Q — строка игральной доски, одна из цифр: 12345678.

Будем считать, что пользователь всегда ходит правильно и контролировать возможность хода не требуется.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class Checkers:
    def __init__(self):
        self.board = {
            'A': {'8': 'X', '7': 'B', '6': 'X','5': 'X',
                  '4': 'X', '3': 'W', '2': 'X', '1': 'W'},
            'B': {'8': 'B', '7': 'X', '6': 'B','5': 'X',
                  '4': 'X', '3': 'X', '2': 'W', '1': 'X'},
            'C': {'8': 'X', '7': 'B', '6': 'X', '5': 'X',
                  '4': 'X', '3': 'W', '2': 'X', '1': 'W'},
            'D': {'8': 'B', '7': 'X', '6': 'B', '5': 'X',
                  '4': 'X', '3': 'X', '2': 'W', '1': 'X'},
            'E': {'8': 'X', '7': 'B', '6': 'X', '5': 'X',
                  '4': 'X', '3': 'W', '2': 'X', '1': 'W'},
            'F': {'8': 'B', '7': 'X', '6': 'B', '5': 'X',
                  '4': 'X', '3': 'X', '2': 'W', '1': 'X'},
            'G': {'8': 'X', '7': 'B', '6': 'X', '5': 'X',
                  '4': 'X', '3': 'W', '2': 'X', '1': 'W'},
            'H': {'8': 'B', '7': 'X', '6': 'B', '5': 'X',
                  '4': 'X', '3': 'X', '2': 'W', '1': 'X'}
        }

    def move(self, f, t):
        tile1 = self.board[f[0]][f[1]]
        tile2 = self.board[t[0]][t[1]]
        self.board[f[0]][f[1]] = tile2
        self.board[t[0]][t[1]] = tile1
        
    def get_cell(self, p):
        return Cell(self.board[p[0]][p[1]])

class Cell:
    def __init__(self, color):
        self.color = color

    def status(self):
        return self.color
```

## I. Очередь
В программировании существует потребность не только в изученных нами коллекциях. Одна из таких очередь. Она реализует подход к хранению данных по принципу «Первый вошёл – первый ушел».  

Реализуйте класс Queue, который не имеет параметров инициализации, но поддерживает методы:  

- push(item) — добавить элемент в конец очереди;  
- pop() — «вытащить» первый элемент из очереди;  
- is_empty() — проверят очередь на пустоту.  

**Примечание**
Ваше решение должно содержать только классы и функции.
В решении не должно быть вызовов инициализации требуемых классов.

---
```python
class Queue:
    def __init__(self):
        self.ls = []
    
    def push(self, item):
        self.ls.append(item)

    def pop(self):
        return self.ls.pop(0)

    def is_empty(self):
        return True if not self.ls else False
```

## J. Стек
Ещё одной полезной коллекцией является стек реализующий принцип «Последний пришёл – первый ушёл». Его часто представляют как стопку карт или магазин пистолета, где приходящие элементы закрывают выход уже находящимся в коллекции.  

Реализуйте класс Stack, который не имеет параметров инициализации, но поддерживает методы:  

- push(item) — добавить элемент в конец стека;  
- pop() — «вытащить» первый элемент из стека;  
- is_empty() — проверяет стек на пустоту.  

**Примечание**  
Ваше решение должно содержать только классы и функции.  
В решении не должно быть вызовов инициализации требуемых классов.  

---
```python
class Stack:
    def __init__(self):
        self.ls = []
    
    def push(self, item):
        self.ls.append(item)

    def pop(self):
        return self.ls.pop(-1)

    def is_empty(self):
        return True if not self.ls else False
```
